# Гайдлайны для тестов

## Для кого

Многие правила подразумевают, что их читает Python-разработчик, а не тестер и не фронтендер. Так что, например, отделу QA эти правила не подойдут.

## Мотивация

Тесты, как и любой код, нужно поддерживать в чистоте. Один из способов улучшить сопровождаемость тестов — ввести список правил. Правила упростят ознакомление с существующими тестами и подскажут, как писать новые.

Эти гайдлайны являются _вводными_. Добавлять сразу много строгих правил сложно и непрактично, лучше начать с малого.

Эти гайдлайны являются _добровольными_. Если какое-то правило не приживётся, от него можно просто избавиться в следующей версии документа.


## Отношение к другим документам

Этот документ дополняет [Python Styleguide](https://github.com/best-doctor/guides/blob/master/guides/python_styleguide.md). При конфликте правил этот документ имеет преимущество.

## Куда класть тесты

Тесты для `bestdoctor/models/clinic.py` должны лежать в `bestdoctor/tests/test_models/test_clinic.py`. Более общее правило: тесты для `bestdoctor/<foo>/<bar>.py` лежат в `bestdoctor/tests/test_<foo>/test_<bar>.py`.

Тесты для `mail/signals.py` должны лежать в `mail/tests.py` или `mail/tests/test_signals.py`. Более общее правило: тесты для `<foo>/<bar>.py` находятся в `<foo>/tests.py` или в `<foo>/tests/test_<bar>.py`.

## Два вида тестов

Разработчикам надо тестировать две вещи:

1. Что фича работает
2. Что функции и методы, составляющие фичу, работают как надо

А соответственно нужны два вида тестов:

1. Относительно долгие, проверящие фичу целиком
2. Несколько быстрых юнит-тестов, тестирующие отдельные составляющие фичи

## `selenium` vs `django.test.Client`

Селениумом слишком тяжёл для наших тестов. К тому же его уже использует QA.

Мы используем `django.test.Client` за его легковесность.

## Скорость выполнения

Мы пока не обращаем внимания на скорость выполнения, но избегаем слишком долгих тестов.

## `success_case` и `error_case`

`success_case`-тест отвечает на вопрос «как должен вести себя код при корректном инпуте». На каждую фичу и её составляющую должен приходится `success_case`-тест.

Если фича/составляющая должна как-то особо обрабатывать некорректный ввод, под неё пишется `error_case`-тест.

## Параметризация

Чтобы избегать дубликации кода при написании тестов, мы их параметризируем с помощью `pytest.parameterize`. Благодаря этому `success_case`-тестов редко бывает больше одного.

## `pytest.xfails` vs `pytest.raises`

Мы используем `pytest.xfails`, чтобы избежать ломающегося билда. Мы используем `pytest.raises`, чтобы показать, что тест проходит только в случае, если поднимается исключение.

## Как обращаться с фабриками

Новые фабрики добавляются в `bestdoctor/factories.py` и регистрируются в `bestdoctor/tests/conftest.py`. Далее они доступны тестам в качестве параметров.

Если тестируемый код находится не в папке `bestdoctor`, то правила расположения `factories.py` и `conftest.py` такие же, как и в случае с тестами (см. выше).

Чаще всего мы не делаем фикстуры из фабрик.

**Плохо:**

```python
@pytest.fixture()
def n_patients_factory(patient_factory):
    def generate_n_patients(patients_num, data_only=False):
        if data_only:
            return patient_factory.build_dict_batch(patients_num)
        return patient_factory.create_batch(patients_num)
```

Это нужно делать в тесте.

## Порядок аргументов теста

Сначала идут параметры теста, затем фабрики.

## Шаблон теста

```python
@pytest.mark.parametrize(
    'param1, param2, ...',
    [
        (value11, value12, ...),
        (value21, value22, ...),
        (value31, value32, ...),
        (..., ..., ...),
    ]
)
@pytest.mark.django_db
def test_foo_bar_success_case(param1, param2, ..., foo_factory, ...):
    # code ...
    assert foo is bar
```

