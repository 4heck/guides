# Frontend StyleGuide and Coding Conventions

Единообразие существенно снижает когнитивную сложность восприятия кода. Все наши проекты должны быть в одном стиле во
всем - наименование, структура и тд. Единообразие и следование правилам важнее чем то, что гласят отдельные правила.

За основу берем
[конфиг от typescript book](https://github.com/basarat/typescript-book/blob/master/docs/styleguide/styleguide.md).

Стараемся большую часть работы по проверки качества кода свалить на софт. Люди ошибаются постоянно, компьютеры -
никогда. Поэтому eslint, prettier, etc - наше все.

## Linting

Общий конфиг для всех проектов лежит пока [тут](https://github.com/best-doctor/eslint-config-bestdoctor).
Подключаем его, при необходимости добавляем специфичные для проекта правила/плагины (например штуки про
react-native для мобилки).

Если проект не полностью соответствует конфигу из-за легаси - временно переводим сломанные правила в warn.
По мере рефакторинга все должно быть поправлено и все исключения убраны.

## Formatting

За него отвечает prettier с такими вот настройками:

```json
{
  "printWidth": 120,
  "semi": true,
  "singleQuote": true,
  "tabWidth": 2,
  "trailingComma": "es5"
}
```

## Project structure

### Общие положения

Мы используем компонентный подход и пытаемся сделать структуру проекта максимально модульной.

В `src` проекта находятся/могут находиться папки:

- components - компоненты приложения.
- api - слой запросов к беку.
- utils - вспомогательные функции, которые шарятся между многими компонентами.
- typings - общие для приложения типы данных.
- constants - статичные константы, например цвета, брейк поинты и тд. Если значение является вычисляемым - например
  ширина конечной области зависящая от размера экрана, это должно быть в utils.
- redux - файлы относящиеся к redux слою, детали в соответствующем разделе.
- img - картинки используемые в ряде компонентов, но не имеющие логики/стилей чтобы вынести их в свой компонент.

Внутри `components` компоненты разбиваются на папки по роли компонентов, например:

- pages
- common
- App

#### Про картинки

Картинку можно оборачивать в компонент если у нее есть свойства которые шарятся вместе с ней, например одинаковый
размер. Это может быть гифка спиннера, которая используется в кнопках и после input в форме. В этом случае мы создаем
компонент Spinner в папке common, в котором будет гифка с навешанными стилями.

Или она логически является частью компонента с определенным поведением. Например это logo.svg, которое является лого
компании и которое всегда является кликабельным. Логично вынести ее в отдельный компонент
в котором она будет обернута в тег a.

Если общих стилей или поведения нет - то картинка помещается в `img` и разные компоненты просто импортируют ее оттуда.

### Компонент

#### Зачем все это надо

1. Модульная структура позволяет легко переиспользовать компоненты и шарить их между разными частями приложения
  или разными приложениями.
1. Разделение компонента на логику в контейнере и представление в файле компонента позволяет:
    1. четко понимать куда нужно идти если нужно что-то изменить;
    1. изолированно тестировать одно и другое;
1. Разбиение компонента на части/подкомпоненты, вынос функций в utils/libs позволяет:
    1. изолированно тестировать все эти части;
    1. уменьшает размер файлов, что существенно упрощает их восприятие;
1. Легко перемещать компонент в структуре приложения, либо между приложениями, при необходимости. Особенно если
  использовать абсолютный импорт.

Компонент - папка названная в camel case, например `MyComponent`.

**В ней обязательно находятся:**

1. `index.ts` который является точкой входа в компонент. В самом простом виде там просто импортируется и
  экспортируется `MyComponentView` из `MyComponentView.tsx`. Если есть контейнер то экспортируется именно он.
  Если есть функции в контейнере либо utils которые используются в подкомпонентах, они так же экспортируются тут.
1. `MyComponentView.tsx` в котором находится верстка и стили компонента.
    1. компонент в нем - всегда stateless;
    1. в нем могут находиться простые функции преобразования данных для отображения, либо объявление хендлеров
      для событий, например форматирование даты и тд. При этом сложные функции выносятся в container либо utils/libs;

**Опционально там могут находиться:**

1. `MyComponentsContainer.tsx` в котором:
    1. state компонента
    1. использования useEffect для обработки изменения state/props
    1. тут же могут находиться функции/интерфейсы которые шарятся между компонентом и контейнером, либо
      подкомпонентами. Но только если они небольшие, если они становятся громоздкими, то они выносятся в utils/libs;
    1. тут же происходит коннект к `redux` через хуки из `redux-react`
1. component parts - файлы с версткой-стилями некоторых кусков `MyComponent`, которые выносятся дабы уменьшить размер
  файла `MyComponent.tsx`. Ничего кроме представления и простой логики преобразования данных для представления в них
  не должно быть. Если они появляются то component part превращается в subcomponent.
1. subcomponents - папки имеющие такую же структуру как компонент, то есть index файл, файл компонента, контейнер
  и тд. Это компоненты которые используются только в корневом компоненте и обладают внутренней логикой, либо
  коннектятся к redux, нуждаются в методах lifecycle и тд.
1. `(utils/libs).ts` - файл с функциями используемыми в компоненте или контейнере, которые выносятся дабы уменьшить
  размер файлов. Подробнее про различия ниже.
1. `__tests__` - папка с тестами компонента. В них находятся snapshot тесты для компонента и юнит-тесты для функций.
1. статика - файлы картинок и тд которые используются в компоненте.

#### Группировка в контейнерах

- Инициализирующие-вычисляемые значения, на основании данных из пропсов, например.
- Стейт - использование useState
- Вычисляемые на основе стейта данные (валидация и тд)
- эффекты
- хендлеры для проброса в компонент

#### Libs vs utils

Разница в том что:

- в utils находятся функции не имеющие отношения к бизнес логики, например форматирование даты, работа с куками,
  проверка области видимости на экране и тд.
- в libs находятся функции напрямую связанные с бизнес логикой приложения. Например обработка ответов бека, сложные
  вычисления специфичных вещей, вроде подбора клиник по франшизе и тд.

#### Размер файла

Чем меньше - тем лучше. Проще воспринимать 5 файлов по 100 строк чем один по 500. При этом разбивание должно быть
максимально логичным - выделяем обособленные куски и выносим их в component parts либо subcomponents.
Объемную логику выносим в utils.

## Names

### Общее

Название должно быть семантичным бизнес логике, то есть обозначать то, чем занимается данная сущность.
Например, компонент для переключения видимости пароля может называться TogglePasswordVisibilityButton.
И не может EyeIconButton. Потому что:

1. Не понятно что именно делает данный элемент.
1. Название зависит от контента/стилей, если вместо картинки с глазом появится картинка с камерой, например, нужно
  переименовывать компонент.

Понятность названия важнее длины, красоты и грамматической правильности.

Общее правило наименования вещей - назвать сущность на русском, перевести на английский, сократить до
минимального понятного.

### Конкретное

Название функция всегда глагол или содержит его.

- get\* - функция возвращает используемое значение.
    - validate*, check* - возвращают bool.
    - format\* - преобразовывает данные.
- set\* - функция устанавливает значение в стейте/сторе.
- handle\*(Change/Click/Press) - для функции оберток над set передаваемых во вьюху.
- fetch\* - функция делает запрос для получения данных.

Переменная всегда существительное.

Boolean - с префиксами is, has, can, has, have, was etc.

Коллекции - множественное число, например errors.

Про коллекции свойств:

- usersPhoneNumbers - номера телефонов юзеров
- userPhoneNumbers - номера телефонов юзера
- usersPhoneNumber - номер телефона юзеров?

Количество сущностей - постфикс Number

Число обозначающее порядковый номер - постфикс Index

Постфикс data - чтобы отличать данные с формы от объекта (например с бека).

Действие не должно смешиваться со состоянием - on-off, closed-open.

## Redux

За основу берем [ducks](https://github.com/erikras/ducks-modular-redux)

В `src` лежит папка `redux`, в ней `reducers.ts` в котором собираются в кучу редьюсеры и `configureStore.ts` где
создается стор, собственно.

Сами редьюсеры в папке `redux/modules` где разбиты ан логические модули. Каждый модуль отвечает за какой-то кусок
логики, например `user`, `clinics` и тд.

Содержимое модуля:

- `actions` - простые синхронные экшены
- `types` - типи данных, в том числе экшенов
- `thunks` - асинхронные экшены с запросами и сложная логика
- `selectors` - селекторы для выдергивания данных из стора
- `reducer` - собственно сам редюсер
- `index` - точка экспорта всего

## Важные вещи

### Понятность

Код пишется один раз, а читается многократно. Понятность - важнейшее качество кода, важнее красоты, элегантности,
микрооптимизации и тд. Код должен быть прост и очевиден.

### Single responsibility

Одна функция выполняет одну задачу, но делает это хорошо.

- Если в названии функции есть and - возможно она слишком много на себя берет и ее нужно разделить?
- Если функция принимает boolean параметр, возможно он переключает ее поведение и ее нужно разделить?
- Если функция в несколько сотен строк кода, возможно стоит вычленить часть логики в другие функции?

#### Параметры функции

Если параметров <4 то они передаются обычно, если >=4 то оборачиваются в объект.

#### Композиция функций

Как правило, если функция принимает слишком много параметров - нужно ее разбивать. Исключения - функции не содержащие
логику в себе, например для передаче кучи полей на бек в одном запросе и тд. При этом функция может содержать
асинхронный код который должен выполнится в момент ее вызова. То есть мы не можем заранее получить какой-то фрагмент
готовых данных и просто передать его в эту функцию. Но, мы можем байндить функции с их параметрами и вызывать их в
нужный момент.
Пример:

##### Было

```typescript
const handleSendButtonClick({
  passportNumber,
  passportGiven,
  passportDate,
  firstName,
  middleName,
  lastName,
  birthDate,
  bestdoctorId,
  phoneNumber,
  email,
}) => {
  // Проверка корректности паспортных данных через сторонний сервис
  // Запрос
  // ...
  // Поиск и валидация юзера в нашей базе
  // Запрос
  // ...
  // Генерация полиса
  // Запрос
  // ...
  // Отправка полиса юзеру на email
  // Запрос
  // ...
}
```

##### Можно сделать

```typescript
const checkPassport = ({
  passportNumber,
  passportGiven,
  passportDate,
  birthDate,
}) => {
  // Проверка корректности паспортных данных через сторонний сервис
  // Запрос
  // ...
  return true
}

const findUser = (bestdoctorId, phoneNumber) => {
  // Поиск и валидация юзера в нашей базе
  // Запрос
  // ...
  return null
}

const generatePolis = ({
  firstName,
  middleName,
  lastName,
  birthDate,
  bestdoctorId,
  phoneNumber,
}) => {
  // Генерация полиса
  // Запрос
  // ...
  return {}
}

const sendPolisToUser = (email, polis) => {
  // Отправка полиса юзеру на email
  // Запрос
  // ...
  return true
}

const checkPassportBinded = checkPassport.bind(null, { passportNumber, passportGiven, passportDate, birthDate })
const findUserBinded = findUser.bind(null, bestdoctorId, phoneNumber)
const generatePolisBinded = generatePolis.bind(null, {
  firstName,
  middleName,
  lastName,
  birthDate,
  bestdoctorId,
  phoneNumber,
})
const sendPolisToUserBindedEmail = sendPolisToUser.bind(null, email)


const handleSendButtonClick = async ({
checkPassportBinded,
findUserBinded,
generatePolisBinded,
sendPolisToUserBindedEmail,
}) => {
  const isPassportValid = await checkPassportBinded()

  if (!isPassportValid) return

  const user = await findUserBinded()

  if (!user) return

  const polis = await generatePolisBinded()

  sendPolisToUserBindedEmail(polis)
}
```

### Комментарии

Комментарии - зло. Они могут устаревать, если их забыли поправить после изменения логики, они могут быть неверными,
они могут быть слишком очевидными или недостаточно детальными. Самодокументируемый код - наше все. Если по коду
функции не понятно что там происходит - значит это плохой нейминг функции и переменных.

Возможно стоит разбить логику на части и вынести их в функции с понятными названиями? Даже если функция изначально
была небольшой - это увеличит понятность.

### Отзывчивость и понятность интерфейса

Нельзя оставлять юзера без фидбека. Если что-то происходит, юзер должен об этом знать.
Пустой экран пока что-то грузится - зло. Нужно показать хоть текстовый лоадер.
Пустой экран когда что-то упало - зло. Нужно показать хотя бы текст "Что-то пошло не так, обнови страницу"

## Мелочи

Логическое условие с кучей переменных - обрабатывай массивом с every/some.
